<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dice Roller</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@600;800&family=JetBrains+Mono:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #1a1520;
    --surface: #241e2e;
    --border: #3a2f4a;
    --accent: #c4a35a;
    --accent-glow: #e8c96880;
    --text: #e8e0f0;
    --text-dim: #8a7e96;
    --red: #c45a5a;
    --green: #5ac47a;
  }

  body {
    font-family: 'JetBrains Mono', monospace;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px;
    background-image:
      radial-gradient(ellipse at 20% 50%, #2a1f3a 0%, transparent 60%),
      radial-gradient(ellipse at 80% 50%, #1f2a3a 0%, transparent 60%);
  }

  h1 {
    font-family: 'Cinzel', serif;
    font-weight: 800;
    font-size: 1.3rem;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 0.15em;
    margin-bottom: 12px;
    text-shadow: 0 0 20px var(--accent-glow);
  }

  .roller {
    width: 100%;
    max-width: 400px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .input-row {
    display: flex;
    gap: 8px;
  }

  input[type="text"] {
    flex: 1;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 14px;
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 1rem;
    outline: none;
    transition: border-color 0.2s;
  }

  input[type="text"]:focus {
    border-color: var(--accent);
    box-shadow: 0 0 12px var(--accent-glow);
  }

  input::placeholder {
    color: var(--text-dim);
    font-size: 0.85rem;
  }

  button.roll-btn {
    background: linear-gradient(135deg, var(--accent), #a8883a);
    color: var(--bg);
    border: none;
    border-radius: 8px;
    padding: 10px 20px;
    font-family: 'Cinzel', serif;
    font-weight: 800;
    font-size: 0.95rem;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: transform 0.1s, box-shadow 0.2s;
    text-transform: uppercase;
  }

  button.roll-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px var(--accent-glow);
  }

  button.roll-btn:active {
    transform: translateY(1px);
  }

  .quick-btns {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .quick-btns button {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 12px;
    color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    cursor: pointer;
    transition: all 0.15s;
  }

  .quick-btns button:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: #2a2235;
  }

  .result-area {
    margin-top: 4px;
    min-height: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
  }

  .result-total {
    font-family: 'Cinzel', serif;
    font-size: 2.8rem;
    font-weight: 800;
    color: var(--accent);
    text-shadow: 0 0 24px var(--accent-glow);
    line-height: 1;
    opacity: 0;
    transform: scale(0.5);
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  .result-total.show {
    opacity: 1;
    transform: scale(1);
  }

  .result-detail {
    font-size: 0.82rem;
    color: var(--text-dim);
    text-align: center;
    line-height: 1.4;
  }

  .result-label {
    font-size: 0.75rem;
    color: var(--text-dim);
    font-style: italic;
  }

  .status {
    width: 100%;
    max-width: 400px;
    margin-top: 12px;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.72rem;
    text-align: center;
  }

  .status.connected {
    background: #1a2e1a;
    border: 1px solid #2a4a2a;
    color: var(--green);
  }

  .status.disconnected {
    background: #2e1a1a;
    border: 1px solid #4a2a2a;
    color: var(--red);
  }

  .status.waiting {
    background: #2e2a1a;
    border: 1px solid #4a3a2a;
    color: var(--accent);
  }

  .error {
    color: var(--red);
    font-size: 0.82rem;
    text-align: center;
  }

  @keyframes shake {
    0%, 100% { transform: scale(1) rotate(0deg); }
    20% { transform: scale(1.1) rotate(-3deg); }
    40% { transform: scale(1.1) rotate(3deg); }
    60% { transform: scale(1.1) rotate(-2deg); }
    80% { transform: scale(1.05) rotate(1deg); }
  }

  .rolling {
    animation: shake 0.4s ease-out;
  }
</style>
</head>
<body>

<h1>&#9876; Dice Roller</h1>

<div class="roller">
  <div class="input-row">
    <input type="text" id="diceInput" placeholder="2d6+3, 1d20, 4d8-2..." autocomplete="off" spellcheck="false">
    <button class="roll-btn" id="rollBtn" onclick="roll()">Roll</button>
  </div>

  <div class="quick-btns">
    <button onclick="quickRoll('1d4')">d4</button>
    <button onclick="quickRoll('1d6')">d6</button>
    <button onclick="quickRoll('1d8')">d8</button>
    <button onclick="quickRoll('1d10')">d10</button>
    <button onclick="quickRoll('1d12')">d12</button>
    <button onclick="quickRoll('1d20')">d20</button>
    <button onclick="quickRoll('1d100')">d100</button>
    <button onclick="quickRoll('2d6')">2d6</button>
  </div>

  <div class="result-area" id="resultArea">
    <div class="result-label">Rola os dados!</div>
  </div>
</div>

<div class="status waiting" id="statusBar">Conectando ao Element...</div>

<script>
// ============================================================
// Matrix Widget API - Direct postMessage implementation
// ============================================================
var MatrixWidget = (function() {
  // Extract widgetId from URL params (Element passes this)
  var params = new URLSearchParams(window.location.search);
  var hashStr = window.location.hash || '';
  if (hashStr.indexOf('?') !== -1) {
    var hashParams = new URLSearchParams(hashStr.substring(hashStr.indexOf('?')));
  } else {
    var hashParams = new URLSearchParams('');
  }

  var widgetId = params.get('widgetId') || hashParams.get('widgetId') || 'dice-roller';
  var parentOrigin = params.get('parentUrl') || hashParams.get('parentUrl') || '*';

  // Try to extract just the origin from parentUrl
  if (parentOrigin !== '*') {
    try {
      var u = new URL(parentOrigin);
      parentOrigin = u.origin;
    } catch(e) {
      parentOrigin = '*';
    }
  }

  var requestCounter = 0;
  var pendingRequests = {};
  var capabilitiesApproved = false;
  var readyCallbacks = [];
  var inElement = (window.parent !== window); // are we in an iframe?

  function genRequestId() {
    return 'dice_' + (++requestCounter) + '_' + Date.now();
  }

  function sendToClient(action, data, inResponseTo) {
    if (!inElement) return;

    var msg;
    if (inResponseTo) {
      // This is a reply to a toWidget request
      msg = {};
      for (var k in inResponseTo) {
        if (inResponseTo.hasOwnProperty(k)) msg[k] = inResponseTo[k];
      }
      msg.response = data;
    } else {
      // This is a new fromWidget request
      msg = {
        api: 'fromWidget',
        widgetId: widgetId,
        requestid: genRequestId(),
        action: action,
        data: data || {}
      };
    }

    window.parent.postMessage(msg, parentOrigin);
    return msg.requestid;
  }

  // Listen for messages from Element
  window.addEventListener('message', function(event) {
    var msg = event.data;
    if (!msg || typeof msg !== 'object') return;

    // Handle toWidget messages from Element
    if (msg.api === 'toWidget' && msg.widgetId === widgetId) {

      if (msg.action === 'supported_api_versions') {
        sendToClient(null, {
          supported_versions: ['0.0.1', '0.0.2']
        }, msg);
      }

      else if (msg.action === 'capabilities') {
        sendToClient(null, {
          capabilities: [
            'org.matrix.msc2762.send.event:m.room.message'
          ]
        }, msg);
      }

      else if (msg.action === 'notify_capabilities') {
        capabilitiesApproved = true;
        readyCallbacks.forEach(function(cb) { cb(); });
        readyCallbacks = [];
      }

      // Acknowledge any other toWidget actions we don't handle
      else {
        sendToClient(null, {}, msg);
      }
    }

    // Handle responses to our fromWidget requests
    if (msg.api === 'fromWidget' && msg.response !== undefined && msg.requestid) {
      if (pendingRequests[msg.requestid]) {
        pendingRequests[msg.requestid](msg.response);
        delete pendingRequests[msg.requestid];
      }
    }
  });

  // Public API
  return {
    inElement: inElement,

    start: function() {
      if (!inElement) return;
      // Signal content loaded
      sendToClient('content_loaded', {});

      // Also proactively send our supported versions
      sendToClient('supported_api_versions', {
        supported_versions: ['0.0.1', '0.0.2']
      });

      // Set a timeout for connection
      setTimeout(function() {
        if (!capabilitiesApproved) {
          var statusBar = document.getElementById('statusBar');
          if (statusBar) {
            statusBar.className = 'status disconnected';
            statusBar.textContent = 'Nao conectado ao Element. Rolagens aparecerao apenas aqui.';
          }
        }
      }, 8000);
    },

    isReady: function() {
      return capabilitiesApproved;
    },

    onReady: function(cb) {
      if (capabilitiesApproved) {
        cb();
      } else {
        readyCallbacks.push(cb);
      }
    },

    sendMessage: function(body, htmlBody) {
      if (!capabilitiesApproved || !inElement) {
        return Promise.reject(new Error('Not connected'));
      }

      return new Promise(function(resolve, reject) {
        var reqId = genRequestId();
        var msg = {
          api: 'fromWidget',
          widgetId: widgetId,
          requestid: reqId,
          action: 'send_event',
          data: {
            type: 'm.room.message',
            content: {
              msgtype: 'm.notice',
              body: body,
              format: 'org.matrix.custom.html',
              formatted_body: htmlBody || body
            }
          }
        };

        pendingRequests[reqId] = function(response) {
          if (response && response.error) {
            reject(new Error(response.error.message || 'Send failed'));
          } else {
            resolve(response);
          }
        };

        window.parent.postMessage(msg, parentOrigin);

        // Timeout after 15s
        setTimeout(function() {
          if (pendingRequests[reqId]) {
            delete pendingRequests[reqId];
            reject(new Error('Timeout'));
          }
        }, 15000);
      });
    }
  };
})();

// ============================================================
// Dice Roller Logic
// ============================================================
var input = document.getElementById('diceInput');
var resultArea = document.getElementById('resultArea');
var statusBar = document.getElementById('statusBar');

input.addEventListener('keydown', function(e) {
  if (e.key === 'Enter') roll();
});

function quickRoll(notation) {
  input.value = notation;
  roll();
}

function parseDice(str) {
  str = str.replace(/\s+/g, '').toLowerCase();
  var parts = [];
  var regex = /([+-]?)(\d*)d(\d+)|([+-]?\d+)/g;
  var match;
  var hasAnyDice = false;

  while ((match = regex.exec(str)) !== null) {
    if (match[3]) {
      hasAnyDice = true;
      var sign = match[1] === '-' ? -1 : 1;
      var count = parseInt(match[2] || '1');
      var faces = parseInt(match[3]);
      if (count < 1 || count > 100) throw new Error('Quantidade de dados: 1-100');
      if (faces < 2 || faces > 1000) throw new Error('Faces do dado: 2-1000');
      parts.push({ type: 'dice', count: count, faces: faces, sign: sign });
    } else if (match[4]) {
      parts.push({ type: 'mod', value: parseInt(match[4]) });
    }
  }

  if (!hasAnyDice) throw new Error('Use a notacao: 2d6, 1d20+5...');
  return parts;
}

function rollDice(parts) {
  var total = 0;
  var rolls = [];

  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    if (part.type === 'dice') {
      var diceRolls = [];
      for (var j = 0; j < part.count; j++) {
        var val = Math.floor(Math.random() * part.faces) + 1;
        diceRolls.push(val);
      }
      var sum = diceRolls.reduce(function(a, b) { return a + b; }, 0) * part.sign;
      total += sum;
      rolls.push({
        label: (part.sign === -1 ? '-' : '') + part.count + 'd' + part.faces,
        values: diceRolls,
        sign: part.sign
      });
    } else {
      total += part.value;
      rolls.push({ label: (part.value >= 0 ? '+' : '') + part.value, values: [], sign: 1 });
    }
  }

  return { total: total, rolls: rolls };
}

function formatRolls(rolls) {
  return rolls.map(function(r) {
    if (r.values.length > 0) {
      return r.label + ' [' + r.values.join(', ') + ']';
    }
    return r.label;
  }).join(' ');
}

function formatRollsHTML(rolls) {
  return rolls.map(function(r) {
    if (r.values.length > 0) {
      var highlighted = r.values.map(function(v) {
        if (r.values.length === 1) return '<b>' + v + '</b>';
        return v;
      }).join(', ');
      return r.label + ' [' + highlighted + ']';
    }
    return r.label;
  }).join(' ');
}

function roll() {
  var notation = input.value.trim();
  if (!notation) {
    input.focus();
    return;
  }

  try {
    var parts = parseDice(notation);
    var result = rollDice(parts);
    var detail = formatRolls(result.rolls);

    // Animate button
    var btn = document.getElementById('rollBtn');
    btn.classList.remove('rolling');
    void btn.offsetWidth;
    btn.classList.add('rolling');

    // Show result in widget
    resultArea.innerHTML =
      '<div class="result-total show">' + result.total + '</div>' +
      '<div class="result-detail">' + detail + '</div>';

    var totalEl = resultArea.querySelector('.result-total');
    totalEl.classList.remove('show');
    void totalEl.offsetWidth;
    totalEl.classList.add('show');

    // Send to Matrix room chat
    var plainText = '\uD83C\uDFB2 ' + notation + ' \u2192 ' + detail + ' = ' + result.total;
    var htmlText = '\uD83C\uDFB2 <b>' + notation + '</b> \u2192 ' +
                   formatRollsHTML(result.rolls) +
                   ' = <b>' + result.total + '</b>';

    if (MatrixWidget.isReady()) {
      MatrixWidget.sendMessage(plainText, htmlText).catch(function(err) {
        console.warn('Failed to send to room:', err);
      });
    }

  } catch (err) {
    resultArea.innerHTML = '<div class="error">' + err.message + '</div>';
  }
}

// ============================================================
// Init
// ============================================================
if (MatrixWidget.inElement) {
  MatrixWidget.start();

  MatrixWidget.onReady(function() {
    statusBar.className = 'status connected';
    statusBar.textContent = 'Conectado! Rolagens serao postadas no chat.';
    // Fade out status after a few seconds
    setTimeout(function() {
      statusBar.style.opacity = '0.4';
    }, 4000);
  });
} else {
  statusBar.className = 'status disconnected';
  statusBar.textContent = 'Modo standalone. Abra como widget no Element para postar no chat.';
}

input.focus();
</script>

</body>
</html>
